import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;

public class TcpServerEosSupport {

    private final Properties config = new Properties();
    private final Map<SocketChannel, byte[]> sessionBuffers = new ConcurrentHashMap<>();
    private final Map<SocketChannel, Long> lastActive = new ConcurrentHashMap<>();
    private final ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();

    private ExecutorService workerPool;
    private Selector selector;
    private ServerSocketChannel serverChannel;
    private final byte[] delimiter;

    public TcpServerEosSupport() {
        loadConfig();
        validateMandatory();
        initializeThreadPool();
        setupShutdownHook();
        String rawDelim = getOpt("DELIMITER", "0x0A");
        this.delimiter = parseDelimiterBytes(rawDelim);
        System.out.println("[DEBUG] Loaded Delimiter: " + rawDelim + " (Bytes: " + Arrays.toString(this.delimiter) + ")");
    }

    private byte[] parseDelimiterBytes(String input) {
        try {
            if (input.startsWith("0x")) {
                String hex = input.substring(2);
                byte[] bytes = new byte[hex.length() / 2];
                for (int i = 0; i < bytes.length; i++) {
                    bytes[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2), 16);
                }
                return bytes;
            }
        } catch (Exception e) {
            System.err.println("[WARN ] Invalid hex format: " + input + ". Defaulting to 0x0A.");
        }
        return new byte[]{0x0A};
    }

    private void loadConfig() {
        try {
            if (Files.exists(Paths.get(".env"))) {
                List<String> lines = Files.readAllLines(Paths.get(".env"));
                for (String line : lines) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) {
                        continue;
                    }
                    String[] parts = line.split("=", 2);
                    if (parts.length == 2) {
                        config.put(parts[0].trim(), parts[1].trim());
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("[WARN ] Error reading .env file.");
        }
    }

    private void validateMandatory() {
        if (!config.containsKey("PORT") || config.getProperty("PORT").trim().isEmpty()) {
            throw new RuntimeException("[FATAL] PORT is required in .env");
        }
    }

    private String getOpt(String key, String defaultValue) {
        return config.getProperty(key, defaultValue);
    }

    private void initializeThreadPool() {
        int max = Integer.parseInt(getOpt("MAX_POOL_SIZE", "20"));
        int core = Integer.parseInt(getOpt("CORE_POOL_SIZE", "10"));
        int queueCap = Integer.parseInt(getOpt("QUEUE_CAPACITY", "1000"));
        long keepAlive = Long.parseLong(getOpt("KEEP_ALIVE_TIME_SECONDS", "60"));

        this.workerPool = new ThreadPoolExecutor(core,
            max,
            keepAlive,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(queueCap),
            new ThreadPoolExecutor.CallerRunsPolicy());
    }

    private void setupShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                cleaner.shutdownNow();
                workerPool.shutdown();
                if (selector != null) {
                    selector.close();
                }
                if (serverChannel != null) {
                    serverChannel.close();
                }
                for (SocketChannel client : sessionBuffers.keySet()) {
                    client.close();
                }
            } catch (IOException e) {
                System.err.println("[ERROR] Shutdown: " + e.getMessage());
            }
        }));
    }

    public void start() throws IOException {
        String host = getOpt("HOST", "0.0.0.0");
        int port = Integer.parseInt(config.getProperty("PORT"));
        long cleanupInterval = Long.parseLong(getOpt("CLEANUP_INTERVAL_MS", "30000"));

        this.selector = Selector.open();
        this.serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(host, port));
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);

        cleaner.scheduleAtFixedRate(this::cleanupIdleConnections,
            cleanupInterval,
            cleanupInterval,
            TimeUnit.MILLISECONDS);

        System.out.println("[INFO ] Server started on " + host + ":" + port);

        while (!Thread.currentThread().isInterrupted()) {
            selector.select();
            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();
            while (iter.hasNext()) {
                SelectionKey key = iter.next();
                iter.remove();
                if (!key.isValid()) {
                    continue;
                }
                if (key.isAcceptable()) {
                    handleAccept(serverChannel, selector);
                } else if (key.isReadable()) {
                    key.interestOps(0);
                    handleRead(key);
                }
            }
        }
    }

    private void handleAccept(ServerSocketChannel serverChannel, Selector selector) throws IOException {
        SocketChannel client = serverChannel.accept();
        client.configureBlocking(false);
        client.socket().setTcpNoDelay(true);
        client.register(selector, SelectionKey.OP_READ);
        sessionBuffers.put(client, new byte[0]);
        lastActive.put(client, System.currentTimeMillis());
    }

    private void handleRead(SelectionKey key) {
        final byte[] activeDelim = this.delimiter;
        workerPool.submit(() -> {
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(8192);
            int limit = Integer.parseInt(getOpt("MAX_MESSAGE_SIZE", "10000"));

            try {
                int bytesRead = client.read(buffer);
                byte[] existing = sessionBuffers.getOrDefault(client, new byte[0]);
                byte[] combined;

                if (bytesRead > 0) {
                    buffer.flip();
                    byte[] incoming = new byte[buffer.remaining()];
                    buffer.get(incoming);
                    lastActive.put(client, System.currentTimeMillis());
                    
                    combined = new byte[existing.length + incoming.length];
                    System.arraycopy(existing, 0, combined, 0, existing.length);
                    System.arraycopy(incoming, 0, combined, existing.length, incoming.length);
                } else {
                    combined = existing;
                }

                int start = 0;
                for (int i = 0; i <= combined.length - activeDelim.length; i++) {
                    boolean match = true;
                    for (int j = 0; j < activeDelim.length; j++) {
                        if (combined[i + j] != activeDelim[j]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        byte[] msg = new byte[i - start];
                        System.arraycopy(combined, start, msg, 0, msg.length);
                        processBusinessLogic(client, msg);
                        start = i + activeDelim.length;
                        i = start - 1;
                    }
                }

                byte[] leftover = new byte[combined.length - start];
                System.arraycopy(combined, start, leftover, 0, leftover.length);

                if (bytesRead == -1) {
                    if (leftover.length > 0) {
                        processBusinessLogic(client, leftover);
                    }
                    closeConnection(client);
                } else {
                    sessionBuffers.put(client, leftover);
                    if (key.isValid()) {
                        key.interestOps(SelectionKey.OP_READ);
                        selector.wakeup();
                    }
                }
            } catch (IOException e) {
                closeConnection(client);
            }
        });
    }

    private void processBusinessLogic(SocketChannel client, byte[] message) {
        try {
            if (message.length > 0) {
                System.out.println("LOG: " + new String(message));
                client.write(ByteBuffer.wrap(message));
            }
        } catch (IOException e) {
            closeConnection(client);
        }
    }

    private void cleanupIdleConnections() {
        long now = System.currentTimeMillis();
        long timeout = Long.parseLong(getOpt("IDLE_TIMEOUT_MS", "600000"));
        lastActive.forEach((client, time) -> {
            if (now - time > timeout) {
                closeConnection(client);
            }
        });
    }

    private void closeConnection(SocketChannel client) {
        try {
            sessionBuffers.remove(client);
            lastActive.remove(client);
            Thread.sleep(50);
            client.close();
        } catch (IOException | InterruptedException ignored) {
        }
    }

    public static void main(String[] args) throws IOException {
        new TcpServerEosSupport().start();
    }
}
